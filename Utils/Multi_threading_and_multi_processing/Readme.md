### 1. 多线程与多进程 
- **线程**就是操作系统调度的最小单元而**进程**是操作系统分配资源的最小单元;
- 一个应用程序至少包括一个进程，而一个进程可以包括多个线程；
- 每个进程在执行过程中拥有独立的内存单元，**而一个线程的多个进程在执行过程中共享内存**; 
- https://zhuanlan.zhihu.com/p/46368084 
- https://www.zhihu.com/question/23474039/answer/269526476
----------------
- 任意时刻，一个CPU只能运行一个进程，其他进程处于非运行状态；
- 但是一个进程里可以有很多线程，每个线程都可以共享该进程的内存；
- 内存就那么大，会存在各个线程抢占的风险，为了防止这种情况，增加"互斥锁"（Mutual exclusion，缩写 Mutex），即一个线程在使用时，
其他线程必须等它结束，才可以继续使用；
- Python中的多线程，由于存在全局解释器锁GIL，不能发挥多线程的优势，
对所有面向I/O的（会调用内建的操作系统C代码的）程序来说，
GIL会在这个I/O调用之前被释放，以允许其他线程在这个线程等待I/O的时候运行。
如果某线程并未使用很多I/O操作，它会在自己的时间片内一直占用处理器和GIL。
也就是说，I/O密集型的Python程序比计算密集型的Python程序更能充分利用多线程的好处。
我们都知道，比方我有一个4核的CPU，那么这样一来，在单位时间内每个核只能跑一个线程，
然后时间片轮转切换。但是Python不一样，***它不管你有几个核，单位时间多个核只能跑一个线程***，
然后时间片轮转。看起来很不可思议？但是这就是GIL搞的鬼。任何Python线程执行前，
必须先获得GIL锁，然后，每执行100条字节码，解释器就自动释放GIL锁，
让别的线程有机会执行。这个GIL全局锁实际上把所有线程的执行代码都给上了锁，
所以，多线程在Python中只能交替执行，即使100个线程跑在100核CPU上，
也只能用到1个核。通常我们用的解释器是官方实现的CPython，要真正利用多核，
除非重写一个不带GIL的解释器。
---
- **重要概念** 
    1. Python多线程不适合计算密集型任务，但是可以利用在I/O密集型任务中；
        - `计算密集型任务`的特点是要进行大量的计算，消耗CPU资源，
        比如计算圆周率、对视频进行高清解码等等，全靠CPU的运算能力。
        这种计算密集型任务虽然也可以用多任务完成，但是任务越多，
        花在任务切换的时间就越多，CPU执行任务的效率就越低，所以，
        要最高效地利用CPU，**计算密集型任务同时进行的数量应当等于CPU的核心数**。
        计算密集型任务的特点是要进行大量的计算，消耗CPU资源，比如计算圆周率、
        对视频进行高清解码等等，全靠CPU的运算能力。
        这种计算密集型任务虽然也可以用多任务完成，但是任务越多，
        花在任务切换的时间就越多，CPU执行任务的效率就越低，所以，
        要最高效地利用CPU，计算密集型任务同时进行的数量应当等于CPU的核心数。
        - 第二种任务的类型是`IO密集型`，涉及到网络、磁盘IO的任务都是IO密集型任务，
        这类任务的特点是CPU消耗很少，任务的大部分时间都在等待IO操作完成
        _（因为IO的速度远远低于CPU和内存的速度）_。对于IO密集型任务，
        任务越多，CPU效率越高，但也有一个限度。
        常见的大部分任务都是IO密集型任务，比如Web应用。IO密集型任务执行期间，
        99%的时间都花在IO上，花在CPU上的时间很少，因此，
        用运行速度极快的C语言替换用Python这样运行速度极低的脚本语言，
        完全无法提升运行效率。对于IO密集型任务，
        最合适的语言就是开发效率最高（代码量最少）的语言，**脚本语言是首选，C语言最差**。

    2. Python虽然不能利用多线程实现多核任务，但可以通过**多进程**实现多核任务。
    多个Python进程有各自独立的GIL锁，互不影响。
    3. IO密集型代码(文件处理、网络爬虫等)，多线程能够有效提升效率(单线程下有IO操作会进行IO等待，
    造成不必要的时间浪费，而开启多线程能在线程A等待时，
    自动切换到线程B，可以不浪费CPU的资源，从而能提升程序执行效率)。
    所以python的多线程对IO密集型代码比较友好。
    4. 多核多线程比单核多线程更差，原因是单核下多线程，每次释放GIL，
    唤醒的那个线程都能获取到GIL锁，所以能够无缝执行，但多核下，
    CPU0释放GIL后，其他CPU上的线程都会进行竞争，
    但GIL可能会马上又被CPU0拿到，
    导致其他几个CPU上被唤醒后的线程会醒着等待到切换时间后又进入待调度状态，
    这样会造成线程颠簸(thrashing)，导致效率更低！ 
    
    5. 并发与并行
        - 多核CPU在某一时间段内同时执行多个进程(并行)
        - 在同一时间点内，同时执行多个进程(并发)
        

### 代码运行
- 第一个代码multi_processing, 用多进程机制处理一个耗时的计算问题: 
`---------单进程-------------------
当前母进程:16697
当前进程pid:16697
结果:1152921504606846976
当前进程pid:16697
结果:1152921504606846976
用时{}s 4.001805782318115
---------多进程，两个进程进行两次循环----------
当前母进程:16697
等待所有子进程完成
子进程:16699---任务1
子进程:16700---任务2
结果:1152921504606846976
结果:1152921504606846976
总共用时2.021434783935547秒`

